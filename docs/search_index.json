[
["index.html", "Notes for Social Network Science Projects using R Chapter 1 Notes for Social Network Science Projects using R", " Notes for Social Network Science Projects using R Alejandro Espinosa-Rada The Mitchell Centre for Social Network Analysis, The University of Manchester 2020-09-06 Chapter 1 Notes for Social Network Science Projects using R My name is Alejandro Espinosa-Rada, and I am currently a PhD student in Sociology and a member of the Mitchell Centre for Social Network Analysis from the University of Manchester. This document are my notes of some of the random stuff that I am interested that involve R, social networks, or statistics. My own implementations would be collected in the netmem: Network Measures using Matrices package. g &lt;- erdos.renyi.game(sample(1:100, 1), p.or.m = runif(1)) G = zen.erdos_renyi(10,0.1) sudo apt-get install g++ "],
["notes-of-optimization.html", "Chapter 2 Notes of Optimization 2.1 Notes of Linear Regression 2.2 Logarithms 2.3 Linear Regression 2.4 Multivariate Normal Distribution", " Chapter 2 Notes of Optimization 2.1 Notes of Linear Regression The following notes are from this BOOK. Most of the original references become from there. Pending, Expand the Guassian elimination notes with an analytical example and an R code Expand the Gram-Schmidt process notes with an analytical example and an R code. 2.2 Logarithms Univariate normal distribution with mean \\(\\mu\\) and variance \\(\\sigma^2\\) is \\(f(x|\\mu, \\sigma^2)=\\frac{1}{\\sqrt{2\\pi\\sigma}}e^{-\\frac{1}{2\\sigma^2}(x-\\mu)^2}\\) and in R we can compute this value as dnorm(0, mean=0, sd=1); dnorm(0) #&gt; [1] 0.3989423 #&gt; [1] 0.3989423 Calculating the equation, we have # Example 1 UniNorm &lt;- function(x, mean=0, sigma=1){ #pi = 3.14159 output &lt;- (1/sqrt(2*pi*sigma))*exp(-(1/2*(sigma)^2)*((x-mean)^2)) print(output) } UniNorm(0) dnorm(0) # Example 2 UniNorm(1) dnorm(1) #&gt; [1] 0.3989423 #&gt; [1] 0.3989423 #&gt; [1] 0.2419707 #&gt; [1] 0.2419707 In practice, the exact number is not used, and the \\(log\\) is used instead. However, in some cases we do need the value in the original scale. Calculating densities with \\(log\\) is much more stable because when the exponential function is used the number become very small for the machine to represent (underflow), and if the ratio is used we could have also big numbers (overflow). The \\(log\\) (and then the \\(exp\\)) resolve some of these issues. 2.3 Linear Regression We express the linear regression in matrix form as, \\(y = X \\beta + \\varepsilon\\) Were \\(y\\) is a vector of size \\(n \\times 1\\) of observed response, \\(X\\) is the \\(n \\times p\\) predictor matrix, \\(\\beta\\) is the \\(p \\times 1\\) coefficient vector, and \\(\\varepsilon\\) is the \\(n \\times 1\\) error vector. To estimate \\(\\beta\\) (via maximum likelihood or least square), is often written in matrix form as \\[ \\hat{\\beta}=(X&#39;X)^{-1}X&#39;y \\] Which could be estimated in R using solve to extract the inverse of the cross product matrix. set.seed(1234) X &lt;- matrix(rnorm(5000 * 100), 5000, 100) y &lt;- rnorm(5000) betahat &lt;- solve(t(X) %*% X) %*% t(X) %*% y head(betahat) #&gt; [,1] #&gt; [1,] 0.013075906 #&gt; [2,] -0.002368796 #&gt; [3,] -0.007509733 #&gt; [4,] 0.004884836 #&gt; [5,] 0.011336186 #&gt; [6,] 0.007056535 Computationally, this is very expensive! Quick look of inverse matrixes to understand the following equation: \\(\\hat{\\beta}=(X&#39;X)^{-1}X&#39;y\\) First, recall that not all square matrixes are inversible, and that there are some properties of the inverse matrix such as: \\(AA^{-1}=I=A^{-1}A\\) \\((AB)^{-1}=B^{-1}A^{-1}\\) \\((A^{T})^{-1}=(A^{-1})^{T}\\) Let use an example to disentangle some of the properties! First, \\[ A = \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\] and \\[ A^{-1} = \\begin{pmatrix} x_{1} &amp; x_{2} \\\\ y_{1} &amp; y_{2} \\end{pmatrix} \\] we also know that \\[ I = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix} \\] All together and considering \\((1)\\) we have \\[ AA^{-1}=I=A^{-1}A= \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\begin{pmatrix} x_{1} &amp; x_{2} \\\\ y_{1} &amp; y_{2} \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix} = \\begin{pmatrix} x_{1} &amp; x_{2} \\\\ y_{1} &amp; y_{2} \\end{pmatrix} \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\] Now, solving the linear system of equation we have \\(ax_{1}+by_{1}=1\\) \\(ax_{2}+by_{2}=0\\) \\(cx_{1}+dy_{1}=0\\) \\(cx_{2}+dy_{2}=1\\) Also, re-arranging some of the terms and doing some elementary row operations we have for: \\(ax_{2}+by_{2}=0\\) That, \\[ y_{2}=\\frac{-a}{b}x_{2} \\] and \\(cx_{1}+dy_{1}=0\\) \\[ y_{1}=\\frac{-c}{d}x_{1} \\] Now, \\(ax_{1}+by_{1}=1\\) we could replace some terms in such a way that, \\[ ax_{1}-\\frac{bc}{d}x_{1}=1 \\] and \\[ x_{1}=\\frac{d}{ad-bc} \\] then \\[ y_{1}=\\frac{-c}{ad-bc} \\] Also, \\[ \\frac{c}{b}x_{2}-\\frac{ad}{b}x_{2}=1 \\] is expressed as \\[ x_{2}=\\frac{b}{bc-ad} \\] and \\[ y_{2}=\\frac{a}{ad-bc} \\] Puting all together we have the inverse of the matrix \\[ A^{-1}= \\frac{1}{ad-bc} \\begin{pmatrix} d &amp; -b \\\\ -c &amp; a \\end{pmatrix} \\] And, considering that the determinant is, \\[ |A| = \\begin{vmatrix} a &amp; b \\\\ c &amp; d \\end{vmatrix} = ad-bc \\] If the resulting value of \\(ad-bc=0\\), then the matrix is not invertible (is singular or degenerate) In R all this calculation is just a simple function. For example, set.seed(1234) X &lt;- matrix(rnorm(100 * 100), 100, 100) inv_X &lt;- solve(X) A better option that is less computationally demanding is re-arranging the terms in the following way: \\[ X&#39;X\\beta = X&#39;y \\] Which, gives the same result set.seed(1234) X &lt;- matrix(rnorm(5000 * 100), 5000, 100) betahat &lt;- solve(crossprod(X), crossprod(X, y)) head(betahat) #&gt; [,1] #&gt; [1,] 0.013075906 #&gt; [2,] -0.002368796 #&gt; [3,] -0.007509733 #&gt; [4,] 0.004884836 #&gt; [5,] 0.011336186 #&gt; [6,] 0.007056535 2.3.1 Gaussian elimination The difference between computing the inverse of \\(X&#39;X\\), and using a Gaussian elimination to compute \\(\\hat{\\beta}\\) is that the solution is numerically more stable and faster. Also, if there are high colinearity amongst the predictors, then the results would be unstable if the inverse in \\(X&#39;X\\) is used. PENDING!!!! (check my algebra notebook) Quick look of Guassian elimination (or row reduction): algorithm to solve linear equations. The idea is to use elementary row operations and modify te matrix to produce a “triangular” matrix with zeros in the bottom left corner (achieving a upper triangular matrix), that is said to be in a reduced row echelon form. For example, we could try the back substitution in an augmented matrix PENDING: edit the matrix R1(ccc|c) \\[ \\begin{array}{ccc|c} 1 &amp; -1 &amp; 5 &amp; -9 \\\\ 2 &amp; -1 &amp; -3 &amp; -19 \\\\ 3 &amp; 1 &amp; 4 &amp; -13 \\end{array} \\] Consiering that we have three rows (\\(R1, R2, R3\\))… I JUST ADD HERE A NICE MATRIX!!!: \\[ A = \\begin{matrix}\\begin{pmatrix}x &amp; y\\end{pmatrix}\\\\\\mbox{}\\end{matrix} \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} \\] here # Data A &lt;- matrix(c(2,-5,4,1,-2.5,1,1,-4,6),byrow=T,nrow=3,ncol=3) b &lt;- matrix(c(-3,5,10),nrow=3,ncol=1) p &lt;- nrow(A) (U.pls &lt;- cbind(A,b)) # Gaussian Elimination U.pls[1,] &lt;- U.pls[1,]/U.pls[1,1] i &lt;- 2 while (i &lt; p+1) { j &lt;- i while (j &lt; p+1) { U.pls[j, ] &lt;- U.pls[j, ] - U.pls[i-1, ] * U.pls[j, i-1] j &lt;- j+1 } while (U.pls[i,i] == 0) { U.pls &lt;- rbind(U.pls[-i,],U.pls[i,]) } U.pls[i,] &lt;- U.pls[i,]/U.pls[i,i] i &lt;- i+1 } for (i in p:2){ for (j in i:2-1) { U.pls[j, ] &lt;- U.pls[j, ] - U.pls[i, ] * U.pls[j, i] } } U.pls # Check: library(pracma) rref(cbind(A, b)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 -5.0 4 -3 #&gt; [2,] 1 -2.5 1 5 #&gt; [3,] 1 -4.0 6 10 #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 0 0 -51.0 #&gt; [2,] 0 1 0 -25.0 #&gt; [3,] 0 0 1 -6.5 #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 0 0 -51.0 #&gt; [2,] 0 1 0 -25.0 #&gt; [3,] 0 0 1 -6.5 Comparing both strategies, we could check that the Gaussian elimination in comparisson with the other strategy is less time consuming library(microbenchmark) library(magrittr) set.seed(1234) X &lt;- matrix(rnorm(5000 * 100), 5000, 100) microbenchmark( inverse = solve(t(X) %*% X) %*% t(X) %*% y, gaussian = solve(crossprod(X), crossprod(X, y)) ) %&gt;% summary(unit = &quot;ms&quot;) %&gt;% knitr::kable(format = &quot;markdown&quot;) expr min lq mean median uq max neval cld inverse 82.10334 88.88371 95.71806 92.91456 99.10285 189.2704 100 b gaussian 27.32902 27.77993 29.71031 27.95967 28.69138 116.5214 100 a On the other hand, the Gaussian elimination would breaks down when there is collinearity in the \\(X\\) matrix. Meaning that the column \\(X\\) would be very similar, but not identical, to the first column of \\(X\\). For example, set.seed(127893) X &lt;- matrix(rnorm(5000 * 100), 5000, 100) W &lt;- cbind(X, X[, 1] + rnorm(5000, sd = 0.0000000001)) solve(crossprod(W), crossprod(W, y)) #&gt; Error in solve.default(crossprod(W), crossprod(W, y)): system is computationally singular: reciprocal condition number = 1.47235e-16 In this case, the cross product matrix \\(W&#39;W\\) is singular (determinant is \\(0\\)) 2.3.2 QR decomposition R use as a default the QR decomposition, that is not fast, but can detect and handle colinear columns in the matrix. Quick look of orthogonal matrix to understand the QR decomposition (also known as QR factorization or QU factorization): \\(A=QR\\). To work out with the orthogonal vector, we often work with orthonormal vectors. That assumes that all the vectors have lenght \\(1\\) (\\(||v_{1}||=1\\), \\(||v_{1}||^{2}=1\\) or \\(v_{1}v_{2}=1\\) for \\(i, 1,2,...k\\)). Therefore, they have all been “normalized” (unit vectors). Two vectors \\(v_{1}\\) and \\(v_{2}\\), are said to be orthogonal if \\(\\langle v_{1},v_{2} \\rangle = 0\\) (sometime expressed as \\(v_{1} \\perp v_{2}\\)) A set of nonzero vectors that are mutually orthogonal are necessarily linearly independent. Meaning that each vector in one is orthogonal to every vector in the other, and said to be normal to that space (normal vector). Example: Assuming that we have a vector \\[ v_{1} = \\begin{pmatrix} 1/3 \\\\ 2/3 \\\\ 2/3 \\end{pmatrix} \\] and \\[ v_{1} = \\begin{pmatrix} 2/3 \\\\ 1/3 \\\\ -2/3 \\end{pmatrix} \\] and \\(B=\\{v_{1}, v_{2}\\}\\). What is the lenght of \\(v_{1}\\) and \\(v_{2}\\)? \\(||v_{1}||^2=v_{1}v_{2}=1/9+4/9+4/9=1\\) and \\(||v_{2}||^2=4/9+1/9+4/9=1\\). We know that we have a normalized set \\(B\\). Are they orthogonal? \\(v_{1}v_{2}=2/9+2/9+-4/9=0\\) If we know that we have a space, such as \\(V=span(v_{1},v_{2})\\), the we can say that \\(B\\) is an ortohonormal basis for \\(V\\). We do know that the QR decomposition decompose a matrix \\(A\\) into a product \\(A=QR\\) of an othogonal matrix \\(Q\\) and an upper triangular matrix \\(R\\). Quick look of the Gram-Schmidt process to compute the QR decomposition. PENDING!!!! (check my algebra notebook) check Knowing that \\(X\\) can be decomposed as \\(X=QR\\), the linear regression \\[ X&#39;X\\beta = X&#39;y \\] can be writted as \\[ R&#39;Q&#39;QR&#39;\\beta = R&#39;Q&#39;y \\\\ R&#39;R\\beta = R&#39;Q&#39;y \\\\ R\\beta = Q&#39;y \\] Considering that \\(Q&#39;Q=I\\), now we have a simpler equation that does not longer require to compute the cross product. Also, due the QR decomposition \\(R\\) is upper triangular and, therefore, we can solve \\(\\beta\\) via Gaussian elimination. Some of the benefits are that the cross product \\(X&#39;X\\) was numerically unstable if it is not properly centered or scaled. To compute the singular matrix \\(W\\) of the example, the QR decomposition continous without error. Notices that the ouput have \\(100\\) and not \\(101\\) ranks, this is because the colinear column. Qw &lt;- qr(W) str(Qw) #&gt; List of 4 #&gt; $ qr : num [1:5000, 1:101] -7.04e+01 -1.15e-02 -8.27e-05 6.89e-03 -1.13e-02 ... #&gt; $ rank : int 100 #&gt; $ qraux: num [1:101] 1.03 1.01 1.03 1.01 1.02 ... #&gt; $ pivot: int [1:101] 1 2 3 4 5 6 7 8 9 10 ... #&gt; - attr(*, &quot;class&quot;)= chr &quot;qr&quot; After understanding the QR decomposition for the matrix, we can now solve the regression equation to estimate \\(\\hat{\\beta}\\) using R: betahat &lt;- qr.coef(Qw, y) tail(betahat, 1) #&gt; [1] NA Notices that the last element in the position \\(101\\) is NA due the colliniarity. Meaning that the coefficient could not be calculated. This approach helps with colliniarity, is better and more stable. However, is slower: library(ggplot2) library(microbenchmark) m &lt;- microbenchmark(solve(t(X) %*% X) %*% t(X) %*% y, solve(crossprod(X), crossprod(X, y)), qr.coef(qr(X), y)) autoplot(m) 2.4 Multivariate Normal Distribution The p-dimensional multivariate Normal density is written as \\[ \\begin{aligned} \\varphi(x|\\mu, \\Sigma)=-\\frac{p}{2}log|\\Sigma|-\\frac{1}{2}(x-\\mu)&#39;\\Sigma ^{ -1}(x-\\mu) \\end{aligned} \\] Quick look of the multivariate Normal density. Considering that the Gaussian or normal distribution for the univariate case is \\(f(x|\\mu, \\sigma^2)=\\frac{1}{\\sqrt{2\\pi\\sigma}}e^{-\\frac{1}{2\\sigma^2}(x-\\mu)^2}\\) With parameters: mean \\(\\mu\\) and variance \\(\\sigma^{2}\\) (standard deviation \\(\\sigma\\)). We know that the maximum likelihood estimates are \\[ \\begin{aligned} \\hat{\\mu}=\\frac{1}{N}\\sum_{i}x^{(i)} \\\\ \\hat{\\sigma}^{2}=\\frac{1}{N}\\sum_{i}(x^{(i)}-\\hat{\\mu})^{2} \\end{aligned} \\] Then, we have the multivariate Normal density which is the extension of this model to vector value random variables in a multidimensional space. In which \\(x\\) would be a vector with \\(d\\) values, with \\(\\mu\\) as the length-d row vector, and \\(\\Sigma\\) a \\(d \\times d\\) matrix.Remember that \\(|\\Sigma|\\) is the determinant matrix of the covariants, The maximum likelihood are similar to the univariate case \\[ \\begin{aligned} \\hat{\\mu}=\\frac{1}{m}\\sum_{j}x^{(j)} \\\\ \\hat{\\Sigma}^{2}=\\frac{1}{m}\\sum_{j}(x^{(j)}-\\hat{\\mu})^{T}(x^{(j)}-\\hat{\\mu}) \\end{aligned} \\] Where \\(\\Sigma\\) is the average of the \\(d \\times d\\) matrix (outer product). For example, If we have two independent Gaussian variables \\(x_{1}\\) and \\(x_{2}\\), normalized with a \\(Z\\) constant \\[ \\begin{aligned} p(x_{1})=\\frac{1}{Z_{1}}exp\\{-\\frac{1}{2\\sigma^{2}_{1}}(x_{1}-\\mu_{1})^{2}\\} \\\\ p(x_{2})=\\frac{1}{Z_{2}}exp\\{-\\frac{1}{2\\sigma^{2}_{2}}(x_{2}-\\mu_{2})^{2}\\} \\end{aligned} \\] We can a new vector concatenating the two vectors, \\(x=[x_{1}x_{2}]\\) we can ask for the distribution of \\(x\\) assuming that \\(x_{1}\\) and \\(x_{2}\\) are independents. Then, the joint distribution is the product of the individual distributions. Then, we have \\[ p(x_{1})p(x_{2})=\\frac{1}{Z_{1}Z_{2}}exp\\{-\\frac{1}{2}\\}(x-\\mu)^{T}\\Sigma^{-1}(x-\\mu) \\\\ \\mu=[\\mu_{1}\\mu_{2}] \\\\ \\Sigma = diag(\\sigma^{2}_{1}, \\sigma^{2}_{2}) \\\\ \\Sigma=\\begin{pmatrix} \\sigma^{2}_{11} &amp; 0 \\\\ 0 &amp; \\sigma^{2}_{22} \\end{pmatrix} \\] From the multivariate Normal density equation, the most time-consuming part is the quadratic form \\[ (x-\\mu)&#39;\\Sigma^{-1}(x-\\mu) = z&#39;\\Sigma^{-1}z \\\\ z=x-\\mu \\] Similarly to the regression example above is the inversion of the of the p-dimensional covariance matrix \\(\\Sigma\\). Taking \\(z\\) as a \\(p \\times 1\\) column vector, then in R this could be expressed as t(z) %*% solve(Sigma) %*% z 2.4.1 Choleskey decomposition Rather than using the literal equation, a similar approach is using the Choleskey decomposition of \\(\\Sigma\\). Quick look of the Choleskey decomposition or Choleskey factorization. here Recall that if all the eigenvalues of \\(A\\) are positive, or if \\(x^{T}Ax\\) is positive for all non-zero vector \\(x\\) (which is equivalent), then we assume that a symmetric \\(n \\times n\\) matrix \\(A\\) is positive definite. If a matrix is positive definite, then it could be defined as \\(A=X&#39;X\\) for a non-singular (non-invertible) matrix \\(X\\). PENDING!!!! (check my algebra notebook) check Quick look of the eigenvalues. PENDING!!!! (check my algebra notebook) Using the Choleskey decomposition for a positive definite matrix on \\(\\Sigma\\), we have \\[ \\Sigma = R&#39;R \\] were \\(R\\) is an upper triangular matrix (also called the square root of \\(\\Sigma\\)). Using Choleskey decomposition on \\(\\Sigma\\) and the rules of matrix algebra, the multivariate Normal density equation can be written as \\[ z&#39;\\Sigma^{-1}z = z&#39;(R&#39;R)^{-1}z \\\\ = z&#39;R^{-1}R&#39;^{-1}z \\\\ = (R&#39;^{-1}z)&#39;R&#39;^{-1}z \\\\ = v&#39;v \\] Where \\(v=R&#39;^{-1}z\\) and is a \\(p \\times 1\\) vector. Also, to avoid inverting \\(R&#39;^{-1}\\) by computing \\(v\\) as solution of the linear system \\[ R&#39;v=z \\] Then, computing \\(v\\), we can compute \\(v&#39;v\\), which is simply the cross-product of two p-dimensional vectors. One of the benefits of using Choleskey decomposition is that gives a way of computing the log-determinant of \\(\\Sigma\\). Where the log-determinant of \\(\\Sigma\\) is simply \\(2\\) times the sum of the log of the diagional elements of \\(R\\). Implementing this in a function set.seed(93287) z &lt;- matrix(rnorm(200 * 100), 200, 100) S &lt;- cov(z) quad.naive &lt;- function(z, S) { Sinv &lt;- solve(S) rowSums((z %*% Sinv) * z) } library(dplyr) quad.naive(z, S) %&gt;% summary #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 76.78 93.31 99.78 100.34 107.33 129.04 Now, a version that use the Choleskey decomposition quad.chol &lt;- function(z, S) { R &lt;- chol(S) v &lt;- backsolve(R, t(z), transpose = TRUE) colSums(v * v) } quad.chol(z, S) %&gt;% summary #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 76.78 93.31 99.78 100.34 107.33 129.04 Comparing both approaches library(microbenchmark) microbenchmark(quad.naive(z, S), quad.chol(z, S)) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq max neval #&gt; quad.naive(z, S) 2.755969 3.020216 4.378261 3.071935 4.750246 17.84528 100 #&gt; quad.chol(z, S) 1.140910 1.404029 2.338647 1.429454 2.100014 12.35883 100 #&gt; cld #&gt; b #&gt; a The Choelsky decomposition is faster. Also, because we know that the covariance matrix in a multivariate Normal is symmetric and positive define we can use the Choleskey decomposition. The naive version does not have that information, therefore, inverte the matrix and takes more time to estimate! "],
["notes-of-r-and-python.html", "Chapter 3 Notes of R and Python 3.1 Connecting R and Python for Social Network Science Projects 3.2 Conda environment 3.3 Installing Social Network Science modules from Python 3.4 Connecting R and Python", " Chapter 3 Notes of R and Python 3.1 Connecting R and Python for Social Network Science Projects My name is Alejandro Espinosa-Rada and I am currentley a PhD student in Sociology and member of the Mitchell Centre for Social Network Analysis at the University of Manchester Pending, Check graph-tool installation Create a new script with a small tutorial of some of the module for social network analysis (maybe: EstimNetDirected) The following script is my notes for Social Network Science Projects to combine R and Python. Also, in my particular case, I am using a Mac OS/Linux operation system. In Windows, please launch the “Anaconda prompt”. In the following, I will only present Mac OS/Linux operation system. 3.2 Conda environment To begin, I will first create an environment that would contain all the python modules of the entire Social Network Science Project using conda. After installing conda in my computer, I open my terminal and add the following line of codes: conda create --name sns python=3.8 anaconda that would create a new environment called sns (Social Network Science) and would also install python version 3.8. 3.3 Installing Social Network Science modules from Python If you are willing to activate the environment from the terminal, then you would have to use conda activate sns. Notice that I give the name sns that could be modified for whatever you prefer. We can install some modules from python activating the environment from the terminal (i.e. conda activate sns), and then running the following codes python -m pip install numpy python -m pip install panda python -m pip install igraph python -m pip install matplotlib python -m pip install leidenalg python -m pip install networkx python -m pip install pyintergraph Or, all at once - python -m pip install numpy panda igraph matplotlib leidenalg networkx pyintergraph Check the modules installed in your environment with pip list. In my personal computer, I had some issues with the visualizations of igraph. Hence, I install some extra modules: python -m pip install cairocffi python -m pip install pycairo Also, I install cairo using the following code suggested in the webpage of pycairo, that use Homebrew: brew install cairo pkg-config After installing some modules, you should now deactivate the session, and you would have to put the following line of code: conda deactivate in your terminal. If you are willing to check your environments, just press: conda info --envs in your terminal. If for some reason you prefer to remove your entire environment, you would have to use the following code: conda remove --name sns --all Is often common for python users to use the Jupyter Notebook, that might be a better option if you are just going to use python. In which case, after activating your conda environment, you could set your working directory through cd [DIRECTORY] in the terminal. Then launch the Jupyter notebook by jupyter notebook. 3.4 Connecting R and Python We can run Python codes directly from R using RMarkdown. I prefer connecting the best of both worlds. Mostly, because in my personal workflow I tend to use statistical models for social networks analysis. Some of these other statistical models that use social networks are: Different models available in Statnet (e.g. exponential random graph models, epidemiological models, relational event models, or the latent position and cluster models for statistical networks) Stochastic actor-oriented model Dynamic Network Actor-Oriented Model Now that I have an environment called sns, I could now start using R and Python together. We would need to install the reticulate package. #install.packages(&quot;reticulate&quot;) library(reticulate) use_condaenv(condaenv = &quot;sns&quot;, conda = &quot;auto&quot;, required = TRUE) main &lt;- import_main() We can also install a package from R using anaconda of Python, and run any Python code in R using py_run_string #reticulate::conda_install(c(&quot;leidenalg&quot;, &quot;igraph&quot;), # envname = &quot;sns&quot;, pip = TRUE) py_run_string(&quot;import numpy as np&quot;) py_run_string(&quot;my_python_array = np.array([2,4,6,8])&quot;) py_run_string(&quot;print(my_python_array)&quot;) Also, we can use python directly from Rmarkdown adding the chunk {python} instead of {r} in the Rmarkdown. For example, we can replicate the classic model of Holland, Laskey &amp; Leinhardt (1983) on Stochastic Block Model using stochastic_block_model import networkx as nx sizes = [75, 75, 300] probs = [[0.25, 0.05, 0.02], [0.05, 0.35, 0.07], [0.02, 0.07, 0.40]] g = nx.stochastic_block_model(sizes, probs, seed=0) len(g) H = nx.quotient_graph(g, g.graph[&#39;partition&#39;], relabel=True) for v in H.nodes(data=True): print(round(v[1][&#39;density&#39;], 3)) for v in H.edges(data=True): print(round(1.0 * v[2][&#39;weight&#39;] / (sizes[v[0]] * sizes[v[1]]), 3)) There are neat packages out there in Python, some of my favourites are: python: general purpose network analysis NetworkX: general purpose network analysis pyintergraph: convert Python-Graph-Objects between networkx, python-igraph and graph-tools snap: general purpose network analysis metaknowledge: computational research in bibliometrics, scientometrics, and network analysis pySciSci: computational research in bibliometrics, scientometrics, and network analysis leiden_lag: for community detection, with a special focus in the leiden algorithm. Some nice codes are available in the official GitHub of CWTS graph-tool: for stochastic block models and other general purpose network analysis EstimNetDirected: Exponential random graph models for big networks "],
["notes-of-r-and-c.html", "Chapter 4 Notes of R and C++ 4.1 RcppArmadillo 4.2 RcppArrayFire 4.3 OTHER NOTES", " Chapter 4 Notes of R and C++ 4.1 RcppArmadillo library(Rcpp) #&gt; Warning: package &#39;Rcpp&#39; was built under R version 3.6.2 cppFunction(&quot;arma::mat v(arma::colvec a) { return a*a.t();}&quot;, depends=&quot;RcppArmadillo&quot;) v(1:3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 2 4 6 #&gt; [3,] 3 6 9 I had a problem compiling codes from RcppArmadillo. A nice discussion of my problem was solved in the here. What I did was to solve my issue: First I install brew install gcc Then, I also install brew cask install gfortran I have some issues with brew cleanup, I will try brew install yarn then sudo yarn cache clean Trying this here… sudo chown -R $(whoami) /usr/local/* Okay, I give up… problem for another day Seems that there is an issue installing Fortran. Alternative solution in here brew upgrade gcc I seems that there is a mayor issue that should be solved connecting R with gcc. To do that, I had to find the following file from my local computer: ~/.R/Makevars/ Inside that file, it was the following code: CC=clang CXX=clang++ Then, I modify everything for: VER=-10 CC=gcc$(VER) CXX=g++$(VER) CFLAGS=-mtune=native -g -O2 -Wall -pedantic -Wconversion CXXFLAGS=-mtune=native -g -O2 -Wall -pedantic -Wconversion FLIBS=-L/usr/local/Cellar/gcc/10.0.1/lib/gcc/10 In my case, i have gcc version 10.0.1 that is why the code have too many 10 in the modified file! (i.e. VER=-10 and FLIBS=-L/usr/local/Cellar/gcc/10.0.1/lib/gcc/10) If you are not sure what is your gcc version, you can check this on your terminal: Check version gcc --version But, Checking the version of fortran: gfortran --version, should it be this? VER=-8.2.0 CC=gcc$(VER) CXX=g++$(VER) CFLAGS=-mtune=native -g -O2 -Wall -pedantic -Wconversion CXXFLAGS=-mtune=native -g -O2 -Wall -pedantic -Wconversion FLIBS=-L/usr/local/Cellar/gcc/8.2.0/lib/gcc/8 Sources of RcppArmadillo: Course of Armadillo Another example using RcppArmadillo library(RcppArmadillo) #&gt; Warning: package &#39;RcppArmadillo&#39; was built under R version 3.6.2 #include &lt;Rcpp.h&gt; // [[ Rcpp :: export ()]] double inner1 (Rcpp::NumericVector x, Rcpp::NumericVector y ){ int K = x.length() ; double ip = 0 ; for (int k = 0 ; k &lt; K ; k++) { ip += x(k) * y(k) ; } return(ip) ; } using namespace Rcpp; can call any Rcpp constructs by their given name without the Rcpp:: prefix: #include &lt;RcppArmadillo.h&gt; using namespace Rcpp; //[[Rcpp::depends(RcppArmadillo)]] double inner2 (arma::vec x, arma::vec y ){ arma::mat ip = x.t() * y ; return(ip(0)) ; } #include &lt;RcppArmadillo.h&gt; #include &lt;cmath.h&gt; //[[Rcpp::depends(RcppArmadillo)]] using namespace Rcpp; // [[Rcpp::export]] double Mutual_Information( arma::mat joint_dist ){ joint_dist = joint_dist/sum(sum(joint_dist)); double mutual_information = 0; int num_rows = joint_dist.n_rows; int num_cols = joint_dist.n_cols; arma::mat colsums = sum(joint_dist,0); arma::mat rowsums = sum(joint_dist,1); for(int i = 0; i &lt; num_rows; ++i){ for(int j = 0; j &lt; num_cols; ++j){ double temp = log((joint_dist(i,j)/(colsums[j]*rowsums[i]))); if(!std::isfinite(temp)){ temp = 0; } mutual_information += joint_dist(i,j) * temp; } } return mutual_information; } #include &lt;RcppArmadillo.h&gt; //[[Rcpp::depends(RcppArmadillo)]] // another simple example: outer product of a vector, // returning a matrix // [[Rcpp::export]] arma::mat rcpparma_outerproduct(const arma::colvec &amp; x){ arma::mat m = x * x.t(); return m; } // and the inner product retunrs a scalar // // [[Rcpp::export]] double rcpparma_innerproduct(const arma::colvec &amp; x){ double v = arma::as_scalar(x.t() * x); return v; } #include &lt;RcppArmadillo.h&gt; // [[Rcpp::depends(RcppArmadillo)]] // [[Rcpp::export]] arma::rowvec colSums(arma::mat mat){ size_t cols = mat.n_cols; arma::rowvec res(cols); for(size_t i=0; i&lt;cols; i++){ res[i] = sum(mat.col(i)); } } 4.2 RcppArrayFire Check this 4.3 OTHER NOTES We can also write some C++ codes directley in RMarkdown adding to the chunck the following line of codes #include &lt;Rcpp.h&gt; // [[Rcpp::export]] int fibonacci(const int x) { if (x == 0 || x == 1) return(x); return (fibonacci(x - 1)) + fibonacci(x - 2); } Now we can use the function created in C++ directley in R fibonacci(10L) #&gt; [1] 55 fibonacci(20L) #&gt; [1] 6765 slowmax &lt;- function(x){ res &lt;- x[1] for(i in 2:length(x)){ if(x[i] &gt; res) res &lt;- x[i] } res } library(microbenchmark) x &lt;- rnorm(1e6) microbenchmark(slowmax(x), max(x)) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq max neval #&gt; slowmax(x) 39.947006 40.211710 42.219549 40.367407 41.044449 85.652271 100 #&gt; max(x) 2.083506 2.105045 2.208948 2.120525 2.227703 5.824717 100 #&gt; cld #&gt; b #&gt; a library(Rcpp) evalCpp(&quot;40 + 2&quot;) #&gt; [1] 42 evalCpp(&quot;exp(1.0)&quot;) #&gt; [1] 2.718282 evalCpp(&quot;sqrt(4.0)&quot;) #&gt; [1] 2 evalCpp(&quot; std::numeric_limits&lt;int&gt;::max()&quot;) #&gt; [1] 2147483647 Check this! Some other stuff: here "]
]
