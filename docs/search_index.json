[
["index.html", "Notes for Social Network Science Projects using R 1 Notes for Social Network Science Projects using R", " Notes for Social Network Science Projects using R Alejandro Espinosa-Rada The Mitchell Centre for Social Network Analysis, The University of Manchester 2020-09-21 1 Notes for Social Network Science Projects using R My name is Alejandro Espinosa-Rada, and I am currently a PhD student in Sociology and a member of the Mitchell Centre for Social Network Analysis from the University of Manchester. This document are my notes of some of the random stuff that I am interested that involve R, social networks, or statistics. My own implementations would be collected in the netmem: Network Measures using Matrices package. You can also check Knitting Networks, the podcast of the Social Network Analysis (some chapters in Spanish and English) hosted by Francisca Ortiz and myself. g &lt;- erdos.renyi.game(sample(1:100, 1), p.or.m = runif(1)) G = zen.erdos_renyi(10,0.1) sudo apt-get install g++ The online version of this document is free to read here, and licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["notes-of-optimization.html", "2 Notes of Optimization 2.1 Notes of Linear Regression 2.2 Logarithms 2.3 Linear Regression 2.4 Multivariate Normal Distribution", " 2 Notes of Optimization 2.1 Notes of Linear Regression The following notes are from this BOOK. Most of the original references become from there. Pending, Expand the Guassian elimination notes with an analytical example and an R code Expand the Gram-Schmidt process notes with an analytical example and an R code. Check 2.2 Logarithms Univariate normal distribution with mean \\(\\mu\\) and variance \\(\\sigma^2\\) is \\(f(x|\\mu, \\sigma^2)=\\frac{1}{\\sqrt{2\\pi\\sigma}}e^{-\\frac{1}{2\\sigma^2}(x-\\mu)^2}\\) and in R we can compute this value as dnorm(0, mean=0, sd=1); dnorm(0) #&gt; [1] 0.3989423 #&gt; [1] 0.3989423 Calculating the equation, we have # Example 1 UniNorm &lt;- function(x, mean=0, sigma=1){ #pi = 3.14159 output &lt;- (1/sqrt(2*pi*sigma))*exp(-(1/2*(sigma)^2)*((x-mean)^2)) print(output) } UniNorm(0) dnorm(0) # Example 2 UniNorm(1) dnorm(1) #&gt; [1] 0.3989423 #&gt; [1] 0.3989423 #&gt; [1] 0.2419707 #&gt; [1] 0.2419707 In practice, the exact number is not used, and the \\(log\\) is used instead. However, in some cases we do need the value in the original scale. Calculating densities with \\(log\\) is much more stable because when the exponential function is used the number become very small for the machine to represent (underflow), and if the ratio is used we could have also big numbers (overflow). The \\(log\\) (and then the \\(exp\\)) resolve some of these issues. 2.3 Linear Regression We express the linear regression in matrix form as, \\(y = X \\beta + \\varepsilon\\) Were \\(y\\) is a vector of size \\(n \\times 1\\) of observed response, \\(X\\) is the \\(n \\times p\\) predictor matrix, \\(\\beta\\) is the \\(p \\times 1\\) coefficient vector, and \\(\\varepsilon\\) is the \\(n \\times 1\\) error vector. To estimate \\(\\beta\\) (via maximum likelihood or least square), is often written in matrix form as \\[ \\hat{\\beta}=(X&#39;X)^{-1}X&#39;y \\] Which could be estimated in R using solve to extract the inverse of the cross product matrix. set.seed(1234) X &lt;- matrix(rnorm(5000 * 100), 5000, 100) y &lt;- rnorm(5000) betahat &lt;- solve(t(X) %*% X) %*% t(X) %*% y head(betahat) #&gt; [,1] #&gt; [1,] 0.013075906 #&gt; [2,] -0.002368796 #&gt; [3,] -0.007509733 #&gt; [4,] 0.004884836 #&gt; [5,] 0.011336186 #&gt; [6,] 0.007056535 Computationally, this is very expensive! Quick look of inverse matrixes to understand the following equation: \\(\\hat{\\beta}=(X&#39;X)^{-1}X&#39;y\\) First, recall that not all square matrixes are inversible, and that there are some properties of the inverse matrix such as: \\(AA^{-1}=I=A^{-1}A\\) \\((AB)^{-1}=B^{-1}A^{-1}\\) \\((A^{T})^{-1}=(A^{-1})^{T}\\) Let use an example to disentangle some of the properties! First, \\[ A = \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\] and \\[ A^{-1} = \\begin{pmatrix} x_{1} &amp; x_{2} \\\\ y_{1} &amp; y_{2} \\end{pmatrix} \\] we also know that \\[ I = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix} \\] All together and considering \\((1)\\) we have \\[ AA^{-1}=I=A^{-1}A= \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\begin{pmatrix} x_{1} &amp; x_{2} \\\\ y_{1} &amp; y_{2} \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix} = \\begin{pmatrix} x_{1} &amp; x_{2} \\\\ y_{1} &amp; y_{2} \\end{pmatrix} \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\] Now, solving the linear system of equation we have \\(ax_{1}+by_{1}=1\\) \\(ax_{2}+by_{2}=0\\) \\(cx_{1}+dy_{1}=0\\) \\(cx_{2}+dy_{2}=1\\) Also, re-arranging some of the terms and doing some elementary row operations we have for: \\(ax_{2}+by_{2}=0\\) That, \\[ y_{2}=\\frac{-a}{b}x_{2} \\] and \\(cx_{1}+dy_{1}=0\\) \\[ y_{1}=\\frac{-c}{d}x_{1} \\] Now, \\(ax_{1}+by_{1}=1\\) we could replace some terms in such a way that, \\[ ax_{1}-\\frac{bc}{d}x_{1}=1 \\] and \\[ x_{1}=\\frac{d}{ad-bc} \\] then \\[ y_{1}=\\frac{-c}{ad-bc} \\] Also, \\[ \\frac{c}{b}x_{2}-\\frac{ad}{b}x_{2}=1 \\] is expressed as \\[ x_{2}=\\frac{b}{bc-ad} \\] and \\[ y_{2}=\\frac{a}{ad-bc} \\] Puting all together we have the inverse of the matrix \\[ A^{-1}= \\frac{1}{ad-bc} \\begin{pmatrix} d &amp; -b \\\\ -c &amp; a \\end{pmatrix} \\] And, considering that the determinant is, \\[ |A| = \\begin{vmatrix} a &amp; b \\\\ c &amp; d \\end{vmatrix} = ad-bc \\] If the resulting value of \\(ad-bc=0\\), then the matrix is not invertible (is singular or degenerate) In R all this calculation is just a simple function. For example, set.seed(1234) X &lt;- matrix(rnorm(100 * 100), 100, 100) inv_X &lt;- solve(X) A better option that is less computationally demanding is re-arranging the terms in the following way: \\[ X&#39;X\\beta = X&#39;y \\] Which, gives the same result set.seed(1234) X &lt;- matrix(rnorm(5000 * 100), 5000, 100) betahat &lt;- solve(crossprod(X), crossprod(X, y)) head(betahat) #&gt; [,1] #&gt; [1,] 0.013075906 #&gt; [2,] -0.002368796 #&gt; [3,] -0.007509733 #&gt; [4,] 0.004884836 #&gt; [5,] 0.011336186 #&gt; [6,] 0.007056535 2.3.1 Gaussian elimination The difference between computing the inverse of \\(X&#39;X\\), and using a Gaussian elimination to compute \\(\\hat{\\beta}\\) is that the solution is numerically more stable and faster. Also, if there are high colinearity amongst the predictors, then the results would be unstable if the inverse in \\(X&#39;X\\) is used. PENDING!!!! (check my algebra notebook) Quick look of Guassian elimination (or row reduction): algorithm to solve linear equations. The idea is to use elementary row operations and modify te matrix to produce a “triangular” matrix with zeros in the bottom left corner (achieving a upper triangular matrix), that is said to be in a reduced row echelon form. For example, we could try the back substitution in an augmented matrix PENDING: edit the matrix R1(ccc|c) \\[ \\begin{array}{ccc|c} 1 &amp; -1 &amp; 5 &amp; -9 \\\\ 2 &amp; -1 &amp; -3 &amp; -19 \\\\ 3 &amp; 1 &amp; 4 &amp; -13 \\end{array} \\] Consiering that we have three rows (\\(R1, R2, R3\\))… I JUST ADD HERE A NICE MATRIX!!!: \\[ A = \\begin{matrix}\\begin{pmatrix}x &amp; y\\end{pmatrix}\\\\\\mbox{}\\end{matrix} \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} \\] here # Data A &lt;- matrix(c(2,-5,4,1,-2.5,1,1,-4,6),byrow=T,nrow=3,ncol=3) b &lt;- matrix(c(-3,5,10),nrow=3,ncol=1) p &lt;- nrow(A) (U.pls &lt;- cbind(A,b)) # Gaussian Elimination U.pls[1,] &lt;- U.pls[1,]/U.pls[1,1] i &lt;- 2 while (i &lt; p+1) { j &lt;- i while (j &lt; p+1) { U.pls[j, ] &lt;- U.pls[j, ] - U.pls[i-1, ] * U.pls[j, i-1] j &lt;- j+1 } while (U.pls[i,i] == 0) { U.pls &lt;- rbind(U.pls[-i,],U.pls[i,]) } U.pls[i,] &lt;- U.pls[i,]/U.pls[i,i] i &lt;- i+1 } for (i in p:2){ for (j in i:2-1) { U.pls[j, ] &lt;- U.pls[j, ] - U.pls[i, ] * U.pls[j, i] } } U.pls # Check: library(pracma) rref(cbind(A, b)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 -5.0 4 -3 #&gt; [2,] 1 -2.5 1 5 #&gt; [3,] 1 -4.0 6 10 #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 0 0 -51.0 #&gt; [2,] 0 1 0 -25.0 #&gt; [3,] 0 0 1 -6.5 #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 0 0 -51.0 #&gt; [2,] 0 1 0 -25.0 #&gt; [3,] 0 0 1 -6.5 Comparing both strategies, we could check that the Gaussian elimination in comparisson with the other strategy is less time consuming library(microbenchmark) library(magrittr) set.seed(1234) X &lt;- matrix(rnorm(5000 * 100), 5000, 100) microbenchmark( inverse = solve(t(X) %*% X) %*% t(X) %*% y, gaussian = solve(crossprod(X), crossprod(X, y)) ) %&gt;% summary(unit = &quot;ms&quot;) %&gt;% knitr::kable(format = &quot;markdown&quot;) expr min lq mean median uq max neval inverse 90.21554 94.90794 103.71136 99.66515 105.4624 334.99834 100 gaussian 27.49114 29.06401 30.84471 29.41411 30.0125 47.91229 100 On the other hand, the Gaussian elimination would breaks down when there is collinearity in the \\(X\\) matrix. Meaning that the column \\(X\\) would be very similar, but not identical, to the first column of \\(X\\). For example, set.seed(127893) X &lt;- matrix(rnorm(5000 * 100), 5000, 100) W &lt;- cbind(X, X[, 1] + rnorm(5000, sd = 0.0000000001)) solve(crossprod(W), crossprod(W, y)) #&gt; Error in solve.default(crossprod(W), crossprod(W, y)): system is computationally singular: reciprocal condition number = 1.47235e-16 In this case, the cross product matrix \\(W&#39;W\\) is singular (determinant is \\(0\\)) 2.3.2 QR decomposition R use as a default the QR decomposition, that is not fast, but can detect and handle colinear columns in the matrix. Quick look of orthogonal matrix to understand the QR decomposition (also known as QR factorization or QU factorization): \\(A=QR\\). To work out with the orthogonal vector, we often work with orthonormal vectors. That assumes that all the vectors have lenght \\(1\\) (\\(||v_{1}||=1\\), \\(||v_{1}||^{2}=1\\) or \\(v_{1}v_{2}=1\\) for \\(i, 1,2,...k\\)). Therefore, they have all been “normalized” (unit vectors). Two vectors \\(v_{1}\\) and \\(v_{2}\\), are said to be orthogonal if \\(\\langle v_{1},v_{2} \\rangle = 0\\) (sometime expressed as \\(v_{1} \\perp v_{2}\\)) A set of nonzero vectors that are mutually orthogonal are necessarily linearly independent. Meaning that each vector in one is orthogonal to every vector in the other, and said to be normal to that space (normal vector). Example: Assuming that we have a vector \\[ v_{1} = \\begin{pmatrix} 1/3 \\\\ 2/3 \\\\ 2/3 \\end{pmatrix} \\] and \\[ v_{1} = \\begin{pmatrix} 2/3 \\\\ 1/3 \\\\ -2/3 \\end{pmatrix} \\] and \\(B=\\{v_{1}, v_{2}\\}\\). What is the lenght of \\(v_{1}\\) and \\(v_{2}\\)? \\(||v_{1}||^2=v_{1}v_{2}=1/9+4/9+4/9=1\\) and \\(||v_{2}||^2=4/9+1/9+4/9=1\\). We know that we have a normalized set \\(B\\). Are they orthogonal? \\(v_{1}v_{2}=2/9+2/9+-4/9=0\\) If we know that we have a space, such as \\(V=span(v_{1},v_{2})\\), the we can say that \\(B\\) is an ortohonormal basis for \\(V\\). We do know that the QR decomposition decompose a matrix \\(A\\) into a product \\(A=QR\\) of an othogonal matrix \\(Q\\) and an upper triangular matrix \\(R\\). Quick look of the Gram-Schmidt process to compute the QR decomposition. PENDING!!!! (check my algebra notebook) check Knowing that \\(X\\) can be decomposed as \\(X=QR\\), the linear regression \\[ X&#39;X\\beta = X&#39;y \\] can be writted as \\[ R&#39;Q&#39;QR&#39;\\beta = R&#39;Q&#39;y \\\\ R&#39;R\\beta = R&#39;Q&#39;y \\\\ R\\beta = Q&#39;y \\] Considering that \\(Q&#39;Q=I\\), now we have a simpler equation that does not longer require to compute the cross product. Also, due the QR decomposition \\(R\\) is upper triangular and, therefore, we can solve \\(\\beta\\) via Gaussian elimination. Some of the benefits are that the cross product \\(X&#39;X\\) was numerically unstable if it is not properly centered or scaled. To compute the singular matrix \\(W\\) of the example, the QR decomposition continous without error. Notices that the ouput have \\(100\\) and not \\(101\\) ranks, this is because the colinear column. Qw &lt;- qr(W) str(Qw) #&gt; List of 4 #&gt; $ qr : num [1:5000, 1:101] -7.04e+01 -1.15e-02 -8.27e-05 6.89e-03 -1.13e-02 ... #&gt; $ rank : int 100 #&gt; $ qraux: num [1:101] 1.03 1.01 1.03 1.01 1.02 ... #&gt; $ pivot: int [1:101] 1 2 3 4 5 6 7 8 9 10 ... #&gt; - attr(*, &quot;class&quot;)= chr &quot;qr&quot; After understanding the QR decomposition for the matrix, we can now solve the regression equation to estimate \\(\\hat{\\beta}\\) using R: betahat &lt;- qr.coef(Qw, y) tail(betahat, 1) #&gt; [1] NA Notices that the last element in the position \\(101\\) is NA due the colliniarity. Meaning that the coefficient could not be calculated. This approach helps with colliniarity, is better and more stable. However, is slower: library(ggplot2) library(microbenchmark) m &lt;- microbenchmark(solve(t(X) %*% X) %*% t(X) %*% y, solve(crossprod(X), crossprod(X, y)), qr.coef(qr(X), y)) autoplot(m) 2.4 Multivariate Normal Distribution The p-dimensional multivariate Normal density is written as \\[ \\begin{aligned} \\varphi(x|\\mu, \\Sigma)=-\\frac{p}{2}log|\\Sigma|-\\frac{1}{2}(x-\\mu)&#39;\\Sigma ^{ -1}(x-\\mu) \\end{aligned} \\] Quick look of the multivariate Normal density. Considering that the Gaussian or normal distribution for the univariate case is \\(f(x|\\mu, \\sigma^2)=\\frac{1}{\\sqrt{2\\pi\\sigma}}e^{-\\frac{1}{2\\sigma^2}(x-\\mu)^2}\\) With parameters: mean \\(\\mu\\) and variance \\(\\sigma^{2}\\) (standard deviation \\(\\sigma\\)). We know that the maximum likelihood estimates are \\[ \\begin{aligned} \\hat{\\mu}=\\frac{1}{N}\\sum_{i}x^{(i)} \\\\ \\hat{\\sigma}^{2}=\\frac{1}{N}\\sum_{i}(x^{(i)}-\\hat{\\mu})^{2} \\end{aligned} \\] Then, we have the multivariate Normal density which is the extension of this model to vector value random variables in a multidimensional space. In which \\(x\\) would be a vector with \\(d\\) values, with \\(\\mu\\) as the length-d row vector, and \\(\\Sigma\\) a \\(d \\times d\\) matrix.Remember that \\(|\\Sigma|\\) is the determinant matrix of the covariants, The maximum likelihood are similar to the univariate case \\[ \\begin{aligned} \\hat{\\mu}=\\frac{1}{m}\\sum_{j}x^{(j)} \\\\ \\hat{\\Sigma}^{2}=\\frac{1}{m}\\sum_{j}(x^{(j)}-\\hat{\\mu})^{T}(x^{(j)}-\\hat{\\mu}) \\end{aligned} \\] Where \\(\\Sigma\\) is the average of the \\(d \\times d\\) matrix (outer product). For example, If we have two independent Gaussian variables \\(x_{1}\\) and \\(x_{2}\\), normalized with a \\(Z\\) constant \\[ \\begin{aligned} p(x_{1})=\\frac{1}{Z_{1}}exp\\{-\\frac{1}{2\\sigma^{2}_{1}}(x_{1}-\\mu_{1})^{2}\\} \\\\ p(x_{2})=\\frac{1}{Z_{2}}exp\\{-\\frac{1}{2\\sigma^{2}_{2}}(x_{2}-\\mu_{2})^{2}\\} \\end{aligned} \\] We can a new vector concatenating the two vectors, \\(x=[x_{1}x_{2}]\\) we can ask for the distribution of \\(x\\) assuming that \\(x_{1}\\) and \\(x_{2}\\) are independents. Then, the joint distribution is the product of the individual distributions. Then, we have \\[ p(x_{1})p(x_{2})=\\frac{1}{Z_{1}Z_{2}}exp\\{-\\frac{1}{2}\\}(x-\\mu)^{T}\\Sigma^{-1}(x-\\mu) \\\\ \\mu=[\\mu_{1}\\mu_{2}] \\\\ \\Sigma = diag(\\sigma^{2}_{1}, \\sigma^{2}_{2}) \\\\ \\Sigma=\\begin{pmatrix} \\sigma^{2}_{11} &amp; 0 \\\\ 0 &amp; \\sigma^{2}_{22} \\end{pmatrix} \\] From the multivariate Normal density equation, the most time-consuming part is the quadratic form \\[ (x-\\mu)&#39;\\Sigma^{-1}(x-\\mu) = z&#39;\\Sigma^{-1}z \\\\ z=x-\\mu \\] Similarly to the regression example above is the inversion of the of the p-dimensional covariance matrix \\(\\Sigma\\). Taking \\(z\\) as a \\(p \\times 1\\) column vector, then in R this could be expressed as t(z) %*% solve(Sigma) %*% z 2.4.1 Choleskey decomposition Rather than using the literal equation, a similar approach is using the Choleskey decomposition of \\(\\Sigma\\). Quick look of the Choleskey decomposition or Choleskey factorization. here Recall that if all the eigenvalues of \\(A\\) are positive, or if \\(x^{T}Ax\\) is positive for all non-zero vector \\(x\\) (which is equivalent), then we assume that a symmetric \\(n \\times n\\) matrix \\(A\\) is positive definite. If a matrix is positive definite, then it could be defined as \\(A=X&#39;X\\) for a non-singular (non-invertible) matrix \\(X\\). PENDING!!!! (check my algebra notebook) check Quick look of the eigenvalues. PENDING!!!! (check my algebra notebook) Using the Choleskey decomposition for a positive definite matrix on \\(\\Sigma\\), we have \\[ \\Sigma = R&#39;R \\] were \\(R\\) is an upper triangular matrix (also called the square root of \\(\\Sigma\\)). Using Choleskey decomposition on \\(\\Sigma\\) and the rules of matrix algebra, the multivariate Normal density equation can be written as \\[ z&#39;\\Sigma^{-1}z = z&#39;(R&#39;R)^{-1}z \\\\ = z&#39;R^{-1}R&#39;^{-1}z \\\\ = (R&#39;^{-1}z)&#39;R&#39;^{-1}z \\\\ = v&#39;v \\] Where \\(v=R&#39;^{-1}z\\) and is a \\(p \\times 1\\) vector. Also, to avoid inverting \\(R&#39;^{-1}\\) by computing \\(v\\) as solution of the linear system \\[ R&#39;v=z \\] Then, computing \\(v\\), we can compute \\(v&#39;v\\), which is simply the cross-product of two p-dimensional vectors. One of the benefits of using Choleskey decomposition is that gives a way of computing the log-determinant of \\(\\Sigma\\). Where the log-determinant of \\(\\Sigma\\) is simply \\(2\\) times the sum of the log of the diagional elements of \\(R\\). Implementing this in a function set.seed(93287) z &lt;- matrix(rnorm(200 * 100), 200, 100) S &lt;- cov(z) quad.naive &lt;- function(z, S) { Sinv &lt;- solve(S) rowSums((z %*% Sinv) * z) } library(dplyr) quad.naive(z, S) %&gt;% summary #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 76.78 93.31 99.78 100.34 107.33 129.04 Now, a version that use the Choleskey decomposition quad.chol &lt;- function(z, S) { R &lt;- chol(S) v &lt;- backsolve(R, t(z), transpose = TRUE) colSums(v * v) } quad.chol(z, S) %&gt;% summary #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 76.78 93.31 99.78 100.34 107.33 129.04 Comparing both approaches library(microbenchmark) microbenchmark(quad.naive(z, S), quad.chol(z, S)) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq max neval #&gt; quad.naive(z, S) 2.527893 2.813426 2.994938 2.856565 2.914456 10.49887 100 #&gt; quad.chol(z, S) 1.416209 1.500875 1.684979 1.522258 1.549739 12.62963 100 The Choelsky decomposition is faster. Also, because we know that the covariance matrix in a multivariate Normal is symmetric and positive define we can use the Choleskey decomposition. The naive version does not have that information, therefore, inverte the matrix and takes more time to estimate! "],
["notes-of-r-and-python.html", "3 Notes of R and Python 3.1 Connecting R and Python for Social Network Science Projects 3.2 Conda environment 3.3 Installing Social Network Science modules from Python 3.4 Connecting R and Python", " 3 Notes of R and Python 3.1 Connecting R and Python for Social Network Science Projects The following script is my notes for Social Network Science Projects to combine R and Python. Also, in my particular case, I am using a Mac OS/Linux operation system. In Windows, please launch the “Anaconda prompt”. In the following, I will only present Mac OS/Linux operation system. 3.2 Conda environment To begin, I will first create an environment that would contain all the python modules of the entire Social Network Science Project using conda. After installing conda in my computer, I open my terminal and add the following line of codes: conda create --name sns python=3.8 anaconda that would create a new environment called sns (Social Network Science) and would also install python version 3.8. 3.3 Installing Social Network Science modules from Python If you are willing to activate the environment from the terminal, then you would have to use conda activate sns. Notice that I give the name sns that could be modified for whatever you prefer. We can install some modules from python activating the environment from the terminal (i.e. conda activate sns), and then running the following codes python -m pip install numpy python -m pip install panda python -m pip install igraph python -m pip install matplotlib python -m pip install leidenalg python -m pip install networkx python -m pip install pyintergraph Or, all at once - python -m pip install numpy panda igraph matplotlib leidenalg networkx pyintergraph Check the modules installed in your environment with pip list. In my personal computer, I had some issues with the visualizations of igraph. Hence, I install some extra modules: python -m pip install cairocffi python -m pip install pycairo Also, I install cairo using the following code suggested in the webpage of pycairo, that use Homebrew: brew install cairo pkg-config I will also install graph-tool using brew (other options in the webpage): brew install graph-tool After installing some modules, you should now deactivate the session, and you would have to put the following line of code: conda deactivate in your terminal. If you are willing to check your environments, just press: conda info --envs in your terminal. If for some reason you prefer to remove your entire environment, you would have to use the following code: conda remove --name sns --all Is often common for python users to use the Jupyter Notebook, that might be a better option if you are just going to use python. In which case, after activating your conda environment, you could set your working directory through cd [DIRECTORY] in the terminal. Then launch the Jupyter notebook by jupyter notebook. 3.4 Connecting R and Python We can run Python codes directly from R using RMarkdown. I prefer connecting the best of both worlds. Mostly, because in my personal workflow I tend to use statistical models for social networks analysis. Some of these other statistical models that use social networks are: Different models available in Statnet (e.g. exponential random graph models, epidemiological models, relational event models, or the latent position and cluster models for statistical networks) Stochastic actor-oriented model Dynamic Network Actor-Oriented Model Now that I have an environment called sns, I could now start using R and Python together. We would need to install the reticulate package. #install.packages(&quot;reticulate&quot;) library(reticulate) use_condaenv(condaenv = &quot;sns&quot;, conda = &quot;auto&quot;, required = TRUE) main &lt;- import_main() We can also install a package from R using anaconda of Python, and run any Python code in R using py_run_string #reticulate::conda_install(c(&quot;leidenalg&quot;, &quot;igraph&quot;), # envname = &quot;sns&quot;, pip = TRUE) py_run_string(&quot;import numpy as np&quot;) py_run_string(&quot;my_python_array = np.array([2,4,6,8])&quot;) py_run_string(&quot;print(my_python_array)&quot;) Also, we can use python directly from Rmarkdown adding the chunk {python} instead of {r} in the Rmarkdown. For example, we can replicate the classic model of Holland, Laskey &amp; Leinhardt (1983) on Stochastic Block Model using stochastic_block_model import networkx as nx sizes = [75, 75, 300] probs = [[0.25, 0.05, 0.02], [0.05, 0.35, 0.07], [0.02, 0.07, 0.40]] g = nx.stochastic_block_model(sizes, probs, seed=0) len(g) H = nx.quotient_graph(g, g.graph[&#39;partition&#39;], relabel=True) for v in H.nodes(data=True): print(round(v[1][&#39;density&#39;], 3)) for v in H.edges(data=True): print(round(1.0 * v[2][&#39;weight&#39;] / (sizes[v[0]] * sizes[v[1]]), 3)) There are neat packages out there in Python, some of my favourites are: python: general purpose network analysis NetworkX: general purpose network analysis pyintergraph: convert Python-Graph-Objects between networkx, python-igraph and graph-tools snap: general purpose network analysis metaknowledge: computational research in bibliometrics, scientometrics, and network analysis pySciSci: computational research in bibliometrics, scientometrics, and network analysis leiden_lag: for community detection, with a special focus in the leiden algorithm. Some nice codes are available in the official GitHub of CWTS graph-tool: for stochastic block models and other general purpose network analysis EstimNetDirected: Exponential random graph models for big networks ALAAMEE: Autologistic Actor Attribute Model (ALAAM) parameter estimation using Equilibrium Expectation (EE) algorithm "],
["notes-of-c-and-r.html", "4 Notes of C++ and R 4.1 C++ and Rcpp 4.2 Rcpp and Social Network Analysis 4.3 Setup 4.4 Rcpp Introduction 4.5 D. Eddelbuettel tutorial", " 4 Notes of C++ and R The following script aims to review the function of Rcpp. As a sociologist, I always struggle to understand some underlying processes, and I am curious about digging a bit more into this issue! WARNING! All my notes are for macOS users. Pending, Deconstruct some C++ codes for clarity Re-write some notes and expand them Add some Rcpp codes for Social Network Analysis (maybe new script) Create a new script for RcppArmadillo 4.1 C++ and Rcpp C++ is a compiled and statistically typed language. According to Wikipedia? C++ is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C programming language, or “C with Classes”. Wikipedia Why Rcpp? Sometimes R code just isn’t fast enough. You’ve used profiling to figure out where your bottlenecks are, and you’ve done everything you can in R, but your code still isn’t fast enough […] learn how to improve performance by rewriting key functions in C++. This magic comes by way of the Rcpp package (Eddelbuettel and François 2011) (with key contributions by Doug Bates, John Chambers, and JJ Allaire). Advanced R From here I would assume that you have some previous background in the C++ programming1. 4.2 Rcpp and Social Network Analysis There are very nice packages written in R that use Rcpp in some part of the codes for social network analysis. Some examples are: lolog multinet NetSim backbone 4.3 Setup Before using Rcpp I would need to install Xcode in the app store. For Windows, Rtool have to be installed, and in Linux use a code such as sudo apt-get install r-base-dev. 4.4 Rcpp Introduction We would now create a C++ function- However, the most important element in the following code to connect R with C++ is this code // [[Rcpp::export]], which allow exporting the cumSum function that is created in the following chunk into R. #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] NumericVector cumSum(NumericVector x) { int n = x.size(); NumericVector out(n); out[0] = x[0]; for (int i = 1; i &lt; n; ++i) { /* ++i: incrementing (adding 1 to a variable) --i: decrementing (subtracting 1 from a variable) i++: increment after the variable&#39;s value is used in the remainder of the expression i--: decrement occurs after the variable&#39;s value is used in the remainder of the expression */ out[i] = out[i-1] + x[i]; } return out; } Same code in R: CumSum &lt;- function(x) { output &lt;- numeric(length(x)) output[1] &lt;- x[1] for (i in 2:length(x)) { output[i] &lt;- output[i-1] + x[i] } return(output) } This is the process that we are calculating with the function in the first iteration \\((0-1)+2\\), then \\((1-1)+3\\), and \\((3-1)+4....\\). Recall that C++ start from \\(0\\) rather than \\(1\\) (in C++, vectors indices start at 0). Now, we have three similar functions. One from base R, the other is a C++ function (called: cumSum), and the loop CumSum created in R. They should give the same results: x &lt;- 1:10 cumsum(x) cumSum(x) CumSum(x) #&gt; [1] 1 3 6 10 15 21 28 36 45 55 #&gt; [1] 1 3 6 10 15 21 28 36 45 55 #&gt; [1] 1 3 6 10 15 21 28 36 45 55 Now, we can compare the performance of each function using microbenchmark. Rcpp should be faster than the R functions: library(magrittr) library(microbenchmark) x &lt;- 1:1000 microbenchmark( native = cumsum(x), loop = CumSum(x), Rcpp = cumSum(x) ) %&gt;% summary(unit = &quot;ms&quot;) %&gt;% knitr::kable(format = &quot;markdown&quot;) expr min lq mean median uq max neval native 0.004750 0.0049275 0.0056320 0.0050425 0.0053665 0.015240 100 loop 0.092223 0.0932315 0.1053320 0.0948280 0.1035500 0.228412 100 Rcpp 0.004096 0.0050155 0.0203097 0.0054730 0.0102755 1.291070 100 The speed and ability to cheaply use resources are two of the main features of C++. Due that is a compiler and not an interpreter is one of the reasons why is faster than R. Using Rcpp we can use C++ codes directley into R (evalCpp) library(Rcpp) # evaluate simple expression as C++ Rcpp::evalCpp(&quot;3 + 2&quot;) #&gt; [1] 5 set.seed(42) Rcpp::evalCpp(&quot;Rcpp::rnorm(2)&quot;) #&gt; [1] 1.3709584 -0.5646982 # maximum numeric limits of my computer in terms of double Rcpp::evalCpp(&quot;std::numeric_limits&lt;double&gt;::max()&quot;) #&gt; [1] 1.797693e+308 Also, we can add functions from C++ (cppFunction) into the R environment. library(Rcpp) ## Example 1 # create a C++ function to be used in R cppFunction(&#39;int add(int x, int y, int z) { int sum = x + y + z; return sum; }&#39;) # R function with same name as C++ function add #&gt; function (x, y, z) #&gt; .Call(&lt;pointer: 0x108b0df70&gt;, x, y, z) add(1, 2, 3) #&gt; [1] 6 ## Example 2 # create a C++ function to be used in R cppFunction(&quot; int exampleCpp11(){ auto x = 10; // guesses type return x; }&quot;, plugins=c(&quot;cpp11&quot;)) ## C++11 is a version of the standard for the programming language C++ # R function with same name as C++ function exampleCpp11() #&gt; [1] 10 ## Other examples cppFunction(&quot; int doubleMe(int a){return a+a;} &quot;) doubleMe #&gt; function (a) #&gt; .Call(&lt;pointer: 0x108b37fa0&gt;, a) a &lt;- 3 doubleMe(a) #&gt; [1] 6 cppFunction(&quot; int f(int a, int b){ return(a+b); } &quot;) f(21, 21) #&gt; [1] 42 f(21.0, 21) #&gt; [1] 42 f(21.5, 21.5) # ! #&gt; [1] 42 #f(21.5, &quot;hello, world&quot;) # error! There are some issues with integer and double Some names that are used in R: integer numbers: int Floating point number: double ## R # literal numbers are double x &lt;- 42 storage.mode(x) #&gt; [1] &quot;double&quot; # integers needs the L suffix y &lt;- 42L storage.mode(y) #&gt; [1] &quot;integer&quot; z &lt;- as.integer(42) storage.mode(z) #&gt; [1] &quot;integer&quot; ## C++ library(Rcpp) # Literal integers are `int` x &lt;- evalCpp(&quot;42&quot;) storage.mode(x) #&gt; [1] &quot;integer&quot; # Suffix with .0 forces a double y &lt;- evalCpp(&quot;42.0&quot;) storage.mode(y) #&gt; [1] &quot;double&quot; # explicit casting with (double) y &lt;- evalCpp(&quot;double(40+2)&quot;) storage.mode(y) #&gt; [1] &quot;double&quot; # Beware of the integer division! # integer division evalCpp(&quot;13/4&quot;) #&gt; [1] 3 # explicit cast, and hence use of double division evalCpp(&quot;(double)13/4&quot;) #&gt; [1] 3.25 The last function of the package Rcpp is sourceCpp() that is the source code in which other functions are built (e.g. evalCpp and cppFunction). This function builds on and extends cxxfunction(). On the features is that can compile a number of functions and create a file from all of them. Also, have some plugins and dependency options (e.g. RcppArmadillo, RcppEigen, RcppSGL). These plugins can also turn on support for C++11, OpenMp, and more. We can also write some C++ codes directly in RMarkdown adding to the chunk the following line of codes Now we will create an example, and create a function called timesTwo and run the C++ code as an R function from C++. The most important element is the code // [[Rcpp::export]] which export the following function into R. Also, we would ask for Rcpp to source the function for us. Behind the scenes Rcpp creates a wrapper, and then Rcpp compiles, links, and loads the wrapper. Notice that std is tacking the standard package of C++ to conduct a second function. #include &lt;Rcpp.h&gt; using namespace Rcpp; // This is a simple example of exporting a C++ function to R. You can // source this function into an R session using the Rcpp::sourceCpp // function (or via the Source button on the editor toolbar). ... // [[Rcpp::export]] NumericVector timesTwo(NumericVector x){ return x * 2; } // You can include R code blocks in C++ files processed with source Cpp // (useful for testing and development). The R code will be automatically // fun after the compilation. /*** R timesTwo(42) cat(&quot;hello!\\n&quot;) timesTwo(c(12,48,28)) */ // [[Rcpp::export]] double cubed(double x){ return std::pow(x, 3); } // [[Rcpp::export]] NumericVector cubedVec(NumericVector x){ return pow(x, 3); } Actually, if we check once again, we would have available the function into our R environment. timesTwo(42) #&gt; [1] 84 cubed(2) #&gt; [1] 8 cubedVec(3) #&gt; [1] 27 Now we would check the speed of a function from R and another from C++. We would try the Fibonacci sequence # An R function f &lt;- function(n){ if(n &lt; 2) return(n) return(f(n-1) + f(n-2)) } sapply(0:10, f) #&gt; [1] 0 1 1 2 3 5 8 13 21 34 55 # A C++ function Rcpp::cppFunction(&#39;int g(int n){ if (n &lt; 2) return(n); return(g(n-1) + g(n-2)); } &#39;) sapply(0:10, g) #&gt; [1] 0 1 1 2 3 5 8 13 21 34 55 # Check time! increase exponentially library(rbenchmark) benchmark(f(10), f(15), f(20))[,1:4] #&gt; test replications elapsed relative #&gt; 1 f(10) 100 0.010 1.0 #&gt; 2 f(15) 100 0.108 10.8 #&gt; 3 f(20) 100 1.112 111.2 # Now we would compare both functions, C++ perform incredible faster! benchmark(f(20), g(20))[,1:4] #&gt; test replications elapsed relative #&gt; 1 f(20) 100 1.136 189.333 #&gt; 2 g(20) 100 0.006 1.000 res &lt;- microbenchmark::microbenchmark(f(20), g(20)) res #&gt; Unit: microseconds #&gt; expr min lq mean median uq max neval #&gt; f(20) 9648.429 10316.9750 11232.48900 10873.3730 11604.2060 16424.554 100 #&gt; g(20) 42.862 43.5735 54.90096 53.6065 55.4295 121.729 100 suppressMessages(microbenchmark:::autoplot.microbenchmark(res)) 4.5 D. Eddelbuettel tutorial Some resources: rcpp Rcpp Gallery Blog LearnCpp cplusplus Seamless R and C++ Integration with Rcpp D. Eddelbuettel tutorial RStudio In comparison with R, C++ is a compiler and not interpreted. Therefore, we may need to supply header location via -I library location via -L library via --llibraryname Then, we would need to provide these items and compile them all together as, g++ -I/usr/include -c qnorm_rmath.cpp g++ -o qnorm_rmath qnorm_rmath.o -L/usr/lib -lRmath Some notes of the differences between R and C++: R is dynamically typed: x &lt;- 3.14; x &lt;- \"foo\" is valid. In C++, each variable must be declared before first use. Common types are int and long (possible with unsigned), float and double, bool, as well as char. No standard string type, though std::string is close. All these variables types are scalars which is fundamentally different from R where everything is a vector class and (struct) allow the creation of composite types; classes add behaviour to data to form objects Variables need to be declared, cannot change Control structures similar to R: for, while, if, switch Functions are similar too but note the difference in position-only matching, also same function name but different arguments allowed in C++ Pointers and memory management: very different but lots of issues people had with C can be avoided via STL (which is something Rcpp promotes too) Sometimes still useful to know that a pointer is… Comparison between C++: Scalar; and Rcpp Vectors int: IntegerVector double: NumericVector char[];std::string: CharacterVector bool: LogicalVector complex: ComplexVector #include &lt;Rcpp.h&gt; // [[Rcpp::export]] double getMax(Rcpp::NumericVector v){ int n = v.size(); // vectors are describing double m = v[0]; // initialize for (int i=0; i&lt;n; i++){ if (v[i] &gt; m){ Rcpp::Rcout &lt;&lt; &quot;Now&quot; &lt;&lt; m &lt;&lt; std::endl; m = v[i]; } } return(m); } getMax(c(20, 201, 18)) #&gt; Now20 #&gt; [1] 201 #include &lt;Rcpp.h&gt; //[[Rcpp::export]] Rcpp::NumericVector colSums(Rcpp::NumericMatrix mat){ size_t cols = mat.cols(); // How big is the matrix? Rcpp::NumericVector res(cols); // knowing the size, we could create a vector for (size_t i=0; i&lt;cols; i++){ // Then operation from 0 from less of the columns res[i] = sum(mat.column(i)); } return(res); } What we did? NumericMatrix and NumericVector go-to types for matrix and vector operationso n floating point variables We prefix with Rcpp:: to make the namespace explicit Accessor functions .rows() and .cols() for dimensions Result vector allocated based on number of columns column Function column(i) extracts a column, gets a vector, and sum() operates on it The last sum() was internally vectorised, no need to loop over all elements Another example #include &lt;Rcpp.h&gt; //[[Rcpp::export]] double getMax(Rcpp::NumericVector v){ int n = v.size(); // vectors are describing double m = v[0]; for (int i=0; i&lt;n; i++){ if (v[i] &gt; m) { Rcpp::Rcout &lt;&lt; &quot;Now&quot; &lt;&lt; m &lt;&lt; std::endl; m = v[i]; } } return(m); } getMax(c(1,4,3,46)) #&gt; Now1 #&gt; Now4 #&gt; [1] 46 struct Date { unsigned int year; unsigned int month; unsigned int day }; struct Person { char firstname[20]; char lastname[20]; struct Date birthday; unsigned long id; }; class Date { private: unsigned int year; unsigned int month; unsigned int date; public: void setDate(int y, int m, int d); int getDay(); int getMonth(); int getYear(); } C++ has vectors as well: written as std::vector&lt;T&gt; where T denotes template meaning different types can be used to instantiate Rcpp::cppFunction(&quot;double getmax2(std::vector&lt;double&gt; v){ int n = v.size(); // vectors are describing double m = v[0]; // initialize for(int i=0; i&lt;n; i++){ if (v[i] &gt; m){ m = v[i]; } } }&quot;) getMax(c(4,5,2)) #&gt; Now4 #&gt; [1] 5 STL vectors are widely used so Rcpp supports them Very useful to access other C++ code and libraries One caveat: Rcpp vectors reuse R memory so no copies STL vectors have different underpinning so copies But not a concern unless you have a) either HUGE data structures, b) or many many calls Rcpp::cppFunction(&quot;void setSecond(Rcpp::NumericVector v){ v[1] = 42; // numeric vector (temporal copy! could not survey) }&quot;) v &lt;- c(1,2,3); setSecond(v); v # as expected #&gt; [1] 1 42 3 v &lt;- c(1L, 2L, 3L); setSecond(v); v # different (vector of integers) #&gt; [1] 1 2 3 #include &lt;Rcpp.h&gt; // [[Rcpp::export]] double getMax(Rcpp::NumericVector v){ return( max(v)); } getMax(c(2,3,4,5)) #&gt; [1] 5 For math operations, it should be used RcppArmadillo! Packages Check this The standard unit of R code organization. Creating packages with Rcpp is easy Create an empty one via Rcpp.package.skeleton() Rstudio has the File -&gt; New Project -&gt; Directory Choices -&gt; Package Choices The vignette Rcpp-packages has fuller details If you are a newbie to C++, you might have some questions. In Reddit there are some FAQ! If you are curious, you can actually hear Bjarne Stroustrup in YouTube↩︎ "]
]
